# Async Sidecar Control Plane

Read-only backend for the Async Sidecar GUI. It orchestrates end-to-end tests, aggregates observability metrics, inspects deployment manifests (Helm/ArgoCD/KEDA/Karpenter), exposes compliance/audit utilities, and serves report artifacts.

Key repo anchors
- E2E Orchestrator: [runner.py](tests/e2e/runner.py:1), [utils.py](tests/e2e/utils.py:1)
- Metrics endpoints (Prometheus exposition):
  - Gateway: [setup_otel()](services/gateway/src/otel.py:330)
  - Explainer: [setup_otel()](services/explainer/src/otel.py:273)
- Helm/Argo/KEDA/Karpenter (read-only):
  - Chart: [Chart.yaml](manifests/helm/hypergraph/Chart.yaml:1)
  - Values: [values.yaml](manifests/helm/hypergraph/values.yaml:1)
  - KEDA template: [keda-scalers.yaml](manifests/helm/hypergraph/templates/keda-scalers.yaml:1)
  - Argo apps: [argocd-apps.yaml](manifests/argocd/argocd-apps.yaml:1)
  - Karpenter pools: [karpenter-provisioners.yaml](manifests/karpenter/karpenter-provisioners.yaml:1)
- Compliance & Audit:
  - OpenAPI: [hypergraph-api.yaml](api/openapi/hypergraph-api.yaml:1)
  - HIF validator: [validate_hif()](libs/hif/validator.py:117)
  - Sanitizer: [sanitize_message()](libs/sanitize/pii.py:72)

What this service provides
- TestRuns:
  - POST /api/testruns (queue a run by shelling to the orchestrator)
  - GET /api/testruns, /api/testruns/{id}
  - WS /ws/testruns/{id}/stream for live run status updates
  - GET /api/testruns/{id}/report.(json|md) for artifacts generated by the orchestrator
- Metrics aggregation:
  - POST /api/metrics/aggregate with { endpoints: [...] } scrapes /metrics from target services and returns presence-based summaries
- Helm/Argo/KEDA/Karpenter checks (read-only):
  - GET /api/helm/checks — uses helm template if available; falls back to textual checks
  - GET /api/argocd/apps — reads Argo app manifest
  - GET /api/keda/scalers — extracts explainer KEDA values & template excerpt
  - GET /api/karpenter/nodepools — verifies CPU/GPU NodePools & NodeClasses
- Compliance & Audit:
  - POST /api/compliance/openapi/check — validates all documented paths are under /v1 per [hypergraph-api.yaml](api/openapi/hypergraph-api.yaml:1)
  - POST /api/compliance/hif/validate — validates HIF or minimally checks meta.version
  - GET /api/audit/search — reads audit JSONL and returns bounded results (scrubbing is enforced in producers per [sanitize_message()](libs/sanitize/pii.py:72))
- Reports:
  - GET /api/reports/export?format=json|md — exports latest consolidated E2E report files

Security & RBAC model
- Modes: AUTH_MODE=none|static
- AUTH_TOKENS_JSON maps "token" => {tenant_id, scopes[], subject}
  - Example (single-tenant read-only):
    {"admin":{"tenant_id":"tA","scopes":["tests.read","observability.read","deployments.read","autoscaling.read","security.read","compliance.read"],"subject":"ops-admin"}}
- Each route declares the required scopes, aligned with gateway’s [rbac_dependency()](services/gateway/src/rbac.py:62).
- Tenant scoping: For static mode, tenant is resolved from token. Admins may pass X-Tenant-ID for read-only cross-tenant views (control plane never mutates cluster state).

Quickstart
1) Create & activate a virtualenv and install dependencies:
   - python3 -m venv .venv && source .venv/bin/activate
   - pip install -r [requirements.txt](control_plane/requirements.txt:1)
2) Start the control plane:
   - python [app.py](control_plane/app.py:1)
   - Env knobs:
     - CP_HOST=0.0.0.0 CP_PORT=8088
     - AUTH_MODE=static
     - AUTH_TOKENS_JSON='{"admin":{"tenant_id":"tA","scopes":["tests.read","observability.read","deployments.read","autoscaling.read","security.read","compliance.read"],"subject":"ops-admin"}}'
3) Static UI (optional): Serve [ui/index.html](ui/index.html:1) with any file server and point it at the control plane URL.

Example cURL snippets
- Start a test run (read-only orchestration):
  - curl -s -X POST http://localhost:8088/api/testruns -H 'Content-Type: application/json' -d '{"base_url":"http://localhost:8080","load_duration":60,"concurrency":100}'
- List runs:
  - curl -s http://localhost:8088/api/testruns | jq .
- Aggregate metrics:
  - curl -s -X POST http://localhost:8088/api/metrics/aggregate -H 'Content-Type: application/json' -d '{"endpoints":["http://localhost:8080/metrics","http://localhost:9090/metrics"]}'
- Helm checks:
  - curl -s http://localhost:8088/api/helm/checks | jq .
- OpenAPI compliance:
  - curl -s -X POST http://localhost:8088/api/compliance/openapi/check | jq .

Limitations (MVP)
- No cluster mutations (read-only).
- Helm checks require helm on PATH; if missing, service falls back to string-based presence checks.
- Audit log path must exist on the host (default /var/log/hypergraph/audit.log).
- HIF strict validation requires jsonschema via producer library; the control plane uses [validate_hif()](libs/hif/validator.py:117) if available, else minimal checks.

Next steps
- Integrate a full SPA (React+TS) with the control plane endpoints for a production UI build.
- Add persisted sessions and SSO adapter for JWT issuance.
- Expand observability panels and correlation views; enrich capacity recommendations by calling [attach_rate_analyzer.py](tools/analysis/attach_rate_analyzer.py:396) if needed via a job endpoint.